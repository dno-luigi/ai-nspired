<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Truth-Engine | ai-n.org</title>
  <!-- Matrix font (Share Tech Mono) -->
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/lib/highlight.min.js"></script>
  
  <style>
    /* ========================================================= */
    /* MATRIX THEME (BASE STYLES) */
    /* ========================================================= */
    :root {
      --bg-color: #0D0208;
      --text-color: #00FF41; /* Primary Green */
      --primary-accent: #00AA22; /* Slightly darker green for borders/shadows */
      --secondary-accent: #FF00FF; /* Magenta/Glitch accent */
      --input-bg: #0A0105;
      --font-mono: 'Share Tech Mono', monospace;
      --shadow-glow: 0 0 15px rgba(0, 255, 65, 0.5);
    }

    html, body {
      min-height: 100vh;
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: var(--font-mono);
      overflow-x: hidden;
      box-sizing: border-box;
    }
    
    /* Ensure all links and text use the theme color unless specifically overridden */
    a {
      color: var(--text-color);
      text-decoration: none;
      text-shadow: 0 0 5px var(--primary-accent);
      transition: color 0.2s, text-shadow 0.2s;
    }
    a:hover {
      color: var(--secondary-accent);
      text-shadow: 0 0 8px var(--secondary-accent);
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      box-sizing: border-box;
      position: relative;
      z-index: 10;
    }

    /* --- Header & Search --- */
    h1 {
      text-align: center;
      color: var(--text-color);
      margin-top: 50px;
      font-size: 3rem;
      text-shadow: var(--shadow-glow);
    }

    .search-box {
      display: flex;
      gap: 10px;
      margin: 30px 0;
    }

    #truth-input {
      flex-grow: 1;
      padding: 12px 15px;
      border: 2px solid var(--primary-accent);
      border-radius: 4px;
      font-size: 1rem;
      font-family: var(--font-mono);
      background-color: var(--input-bg);
      color: var(--text-color);
      box-shadow: inset 0 0 5px var(--primary-accent);
    }
    #truth-input::placeholder {
        color: rgba(0, 255, 65, 0.5);
    }
    #truth-input:focus {
        outline: none;
        border-color: var(--text-color);
        box-shadow: 0 0 10px var(--text-color);
    }

    #search-btn {
      padding: 12px 20px;
      background-color: var(--primary-accent);
      color: var(--bg-color);
      border: 1px solid var(--text-color);
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: bold;
      transition: background-color 0.2s, box-shadow 0.2s;
      box-shadow: 0 0 5px var(--primary-accent);
    }
    #search-btn:hover {
      background-color: var(--text-color);
      box-shadow: 0 0 15px var(--text-color);
    }

    /* --- Result Panel --- */
    #result-panel {
      padding: 20px;
      border-radius: 4px;
      min-height: 300px;
      background-color: #0A0105;
      border: 1px dashed var(--primary-accent);
      box-shadow: var(--shadow-glow);
      line-height: 1.6;
    }
    
    #result-panel.loading {
      text-align: center;
      opacity: 0.5;
    }

    /* --- Action Buttons (Minimalist Icons) --- */
    .action-bar {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      align-items: center;
      justify-content: flex-start;
    }

    .action-bar button, .action-bar audio {
        /* Icon-Only Styling */
        padding: 8px 12px; 
        border: 1px solid var(--primary-accent);
        background-color: var(--input-bg);
        color: var(--text-color); 
        border-radius: 4px;
        cursor: pointer;
        font-size: 1.2rem;
        line-height: 1;
        transition: all 0.2s;
        box-shadow: 0 0 5px rgba(0, 255, 65, 0.2);
    }
    .action-bar button:hover {
        background-color: var(--text-color);
        color: var(--bg-color); 
        box-shadow: 0 0 10px var(--text-color);
    }
    .action-bar audio {
        padding: 0 5px;
        height: 35px;
        /* Make HTML5 player controls visible on dark background */
        filter: invert(1) hue-rotate(120deg); 
    }

    /* Message box */
    #status-message {
        color: var(--text-color) !important;
        text-shadow: 0 0 5px var(--text-color);
    }

    /* --- History Panel (Styled like terminal output) --- */
    #history-panel {
      margin-top: 40px;
      padding: 20px;
      background-color: #0A0105;
      border-radius: 4px;
      box-shadow: var(--shadow-glow);
      border: 1px dashed var(--primary-accent);
    }
    #history-panel h2 {
      margin-top: 0;
      border-bottom: 1px solid var(--primary-accent);
      padding-bottom: 10px;
      color: var(--text-color);
      text-shadow: 0 0 5px var(--primary-accent);
    }
    .history-item {
      padding: 5px 0;
      border-bottom: 1px dotted rgba(0, 255, 65, 0.2);
    }
    .history-item:last-child {
      border-bottom: none;
    }
    .history-item a {
      font-weight: 400;
    }
    
    /* --- Markdown & Embed Styling --- */
    #result-panel pre {
        background-color: #000000 !important;
        border: 1px solid var(--primary-accent);
        padding: 10px;
        border-radius: 4px;
        overflow-x: auto;
        box-shadow: inset 0 0 5px rgba(0, 255, 65, 0.2);
    }
    #result-panel code {
        color: var(--text-color); 
        background: none !important;
    }
    #result-panel blockquote {
        border-left: 4px solid var(--secondary-accent);
        padding-left: 15px;
        margin: 1em 0;
        opacity: 0.9;
        color: var(--secondary-accent);
        text-shadow: 0 0 2px var(--secondary-accent);
    }

    /* ========================================================= */
    /* DYNAMIC THEMES (Custom themes for result panel) */
    /* ========================================================= */

    /* --- Glitch Theme --- */
    .theme-glitch {
        background: #0d011d !important;
        color: #00ff66 !important;
        border: 2px solid #ff00ff !important;
        box-shadow: 0 0 15px rgba(255, 0, 255, 0.8) !important;
        text-shadow: 1px 1px 0 #ff00ff;
    }
    .theme-glitch h1, .theme-glitch h2, .theme-glitch h3 {
        color: #00ff66 !important;
        text-shadow: 2px 2px 0 #ff00ff;
        border-bottom: 1px dashed #ff00ff;
    }

    /* --- Dossier Theme (Paper look) --- */
    .theme-dossier {
        background: #fcf8e3 !important; 
        color: #1a1a1a !important;
        border: 1px dashed #6d6d6d !important;
        box-shadow: 3px 3px 0 #6d6d6d !important;
        font-family: 'Inter', sans-serif !important;
        text-shadow: none !important;
    }
    .theme-dossier h1, .theme-dossier h2 {
        border-bottom: 2px solid #cc0000 !important;
        color: #cc0000 !important;
    }
    .theme-dossier a { color: #006600 !important; }
    .theme-dossier blockquote { border-left: 5px solid #6d6d6d; background: #eee; }
    .theme-dossier pre { background: #e0e0e0 !important; border: 1px solid #999; }
    .theme-dossier code { color: #555555 !important; }

    /* --- System Theme (Pure Green Matrix) --- */
    .theme-system {
        background: #000000 !important;
        color: #00ff00 !important;
        border: 2px solid #008000 !important;
        text-shadow: 0 0 5px #00ff00;
        box-shadow: none !important;
    }


    @media (max-width: 600px) {
        h1 { font-size: 2rem; margin-top: 30px; }
        .search-box { flex-direction: column; }
        #search-btn { width: 100%; }
        .action-bar { justify-content: space-around; } 
        .action-bar button { width: 45%; }
        .action-bar audio { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>TRUTH ENGINE</h1>

    <div class="search-box">
      <input type="text" id="truth-input" placeholder="Enter query..." title="Enter your query and press Enter or Search">
      <button id="search-btn">SEARCH</button>
    </div>

    <div class="action-bar">
        <button id="speak-btn" title="Speak Response">
            <span id="speak-icon">ðŸ”Š</span>
        </button>
        <button id="copy-btn" title="Copy Output">ðŸ“‹</button>
        <audio id="audio-player" controls style="display:none;"></audio>
    </div>

    <!-- Message box for copy/loading status -->
    <div id="status-message" style="margin-top: 15px; text-align: center; font-weight: bold; display: none;"></div>

    <!-- The result panel where content and theme will be applied -->
    <div id="result-panel" class="result-panel">
      <p style="text-align:center; opacity: 0.6; padding: 100px 0;">INITIATING SEQUENCE... READY FOR QUERY INPUT.</p>
    </div>

    <div id="history-panel">
      <h2>// SYSTEM LOG [HISTORY]</h2>
      <div id="history-list">
        <p style="text-align: center; opacity: 0.6;">No recent protocols detected.</p>
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const API_BASE = "https://justice.ai-n.workers.dev";
    const TTS_MODEL = "gemini-2.5-flash-preview-tts";
    const apiKey = ""; // API key is provided by the environment

    const elements = {
      truthInput: document.getElementById('truth-input'),
      searchBtn: document.getElementById('search-btn'),
      resultPanel: document.getElementById('result-panel'),
      historyList: document.getElementById('history-list'),
      statusMessage: document.getElementById('status-message'),
      copyBtn: document.getElementById('copy-btn'),
      speakBtn: document.getElementById('speak-btn'),
      speakIcon: document.getElementById('speak-icon'),
      audioPlayer: document.getElementById('audio-player'),
    };
    
    // --- Utility Functions ---

    function copyToClipboard(text) {
        const tempElement = document.createElement('textarea');
        tempElement.value = text;
        document.body.appendChild(tempElement);
        tempElement.select();
        try {
            document.execCommand('copy');
            return true;
        } catch (err) {
            console.error('Copy failed:', err);
            return false;
        } finally {
            document.body.removeChild(tempElement);
        }
    }

    function showStatus(message, duration = 3000) {
        elements.statusMessage.textContent = message;
        elements.statusMessage.style.display = 'block';
        setTimeout(() => elements.statusMessage.style.display = 'none', duration);
    }

    // Converts raw PCM data (Int16Array) to a playable WAV Blob
    function pcmToWav(pcm16, sampleRate) {
        const buffer = new ArrayBuffer(44 + pcm16.length * 2);
        const view = new DataView(buffer);
        
        // RIFF chunk descriptor
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + pcm16.length * 2, true);
        writeString(view, 8, 'WAVE');
        
        // FMT sub-chunk
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true); // PCM format (1)
        view.setUint16(22, 1, true); // Mono (1 channel)
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true); // Byte rate (SampleRate * Channels * BitsPerSample/8)
        view.setUint16(32, 2, true); // Block align (Channels * BitsPerSample/8)
        view.setUint16(34, 16, true); // Bits per sample (16)
        
        // DATA sub-chunk
        writeString(view, 36, 'data');
        view.setUint32(40, pcm16.length * 2, true);
        
        // Write PCM data
        for (let i = 0; i < pcm16.length; i++) {
            view.setInt16(44 + i * 2, pcm16[i], true);
        }
        
        return new Blob([buffer], { type: 'audio/wav' });
    }
    
    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    // Function to handle TTS generation
    async function fetchTTS(htmlContent) {
        elements.audioPlayer.style.display = 'none';
        elements.audioPlayer.pause();
        elements.speakIcon.innerHTML = '...'; // Show generating state
        elements.speakBtn.disabled = true;

        // Clean up text
        const cleanText = htmlContent.replace(/<[^>]+>/g, '').replace(/[\*\_#]/g, '').trim();
        if (!cleanText) {
             elements.speakIcon.innerHTML = 'ðŸ”Š';
             elements.speakBtn.disabled = false;
             return showStatus('Protocol failure: No content detected for speech.', 3000);
        }

        const payload = {
            contents: [{ parts: [{ text: cleanText }] }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: "Kore" }
                    }
                }
            },
            model: TTS_MODEL
        };
        
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent?key=${apiKey}`;

        try {
            const response = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                const rateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                const audioUrl = URL.createObjectURL(wavBlob);
                
                elements.audioPlayer.src = audioUrl;
                elements.audioPlayer.style.display = 'block';
                elements.speakIcon.innerHTML = 'ðŸŽ§'; // Playing icon
                elements.speakBtn.disabled = false;
                elements.audioPlayer.play();
                elements.audioPlayer.onended = () => {
                    elements.speakIcon.innerHTML = 'ðŸ”Š'; // Reset to speaker icon
                };
            } else {
                throw new Error("Invalid audio data format received.");
            }
        } catch (error) {
            console.error("TTS Error:", error);
            showStatus('TTS system error. Could not generate audio file.', 5000);
            elements.speakIcon.innerHTML = 'ðŸ”Š'; // Reset to speaker icon
            elements.speakBtn.disabled = false;
        }
    }
    
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    // Function to handle API calls with exponential backoff
    async function fetchWithRetry(url, options, retries = 3) {
        for (let i = 0; i < retries; i++) {
            try {
                const response = await fetch(url, options);
                if (response.status !== 429) return response;
                
                // Exponential backoff for rate limiting (429)
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            } catch (error) {
                if (i === retries - 1) throw error;
                console.warn(`[PROTOCOL] Fetch attempt ${i+1} failed. Retrying...`);
            }
        }
        throw new Error('All fetch retries failed. System offline.');
    }
    
    // --- Core Logic ---

    function saveHistory(query) {
      let history = JSON.parse(localStorage.getItem('truthEngineHistory') || '[]');
      history = [query, ...history.filter(q => q !== query)];
      history = history.slice(0, 10);
      localStorage.setItem('truthEngineHistory', JSON.stringify(history));
      renderHistory(history);
    }

    function renderHistory(history) {
      if (history.length === 0) {
        elements.historyList.innerHTML = '<p style="text-align: center; opacity: 0.6;">No recent protocols detected.</p>';
        return;
      }
      elements.historyList.innerHTML = '';
      history.forEach(q => {
        const item = document.createElement('div');
        item.className = 'history-item';
        // Use an anchor tag with data-q for re-running the query
        item.innerHTML = `<span style="opacity:0.6;">QUERY ></span> <a href="#" data-q="${encodeURIComponent(q)}">${q}</a>`;
        elements.historyList.appendChild(item);
      });
    }
    
    elements.historyList.addEventListener('click', function(e) {
        if (e.target.tagName === 'A' && e.target.hasAttribute('data-q')) {
            e.preventDefault();
            const q = decodeURIComponent(e.target.getAttribute('data-q'));
            elements.truthInput.value = q;
            runQuery(q);
        }
    });

    /**
     * Finds theme instruction and applies CSS class, then renders content.
     */
    function renderContentWithTheme(markdownContent) {
        elements.resultPanel.className = 'result-panel'; // Reset class
        
        let content = markdownContent;
        let themeClass = '';

        // 1. Check for theme instruction (e.g., <!-- theme:glitch -->)
        const themeMatch = content.match(/<!--\s*theme:(\w+)\s*-->/i);
        if (themeMatch) {
            const theme = themeMatch[1].toLowerCase();
            if (['glitch', 'dossier', 'system'].includes(theme)) {
                themeClass = `theme-${theme}`;
                // Remove the theme instruction from the content before rendering
                content = content.replace(themeMatch[0], '').trim();
            }
        }

        // Apply theme class to the result panel
        if (themeClass) {
            elements.resultPanel.classList.add(themeClass);
        }

        // 2. Render Markdown/HTML
        elements.resultPanel.innerHTML = marked.parse(content);
        
        // 3. Highlight code blocks
        document.querySelectorAll('#result-panel pre code').forEach(block => {
            hljs.highlightElement(block);
        });

        // 4. Check and handle embedded link behavior inside the rendered content
        handleEmbeddedLinks(elements.resultPanel);
    }

    function handleEmbeddedLinks(container) {
        container.querySelectorAll('a').forEach(link => {
            try {
                const url = new URL(link.href);
                // Handle local query links (e.g., ?q=...)
                if (url.pathname === window.location.pathname && url.searchParams.has('q')) {
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        const q = url.searchParams.get('q');
                        if (q) {
                            elements.truthInput.value = q;
                            runQuery(q);
                        }
                    });
                }
                // Handle custom search links (e.g., data-search/...)
                if (link.getAttribute('href') && link.getAttribute('href').startsWith('data-search/')) {
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        const q = decodeURIComponent(link.getAttribute('href').slice('data-search/'.length));
                        if (q) {
                            elements.truthInput.value = q;
                            runQuery(q);
                        }
                    });
                }
            } catch(e) {}
        });
    }

    async function runQuery(query) {
      if (!query) return;

      saveHistory(query);
      elements.resultPanel.innerHTML = '<p style="text-align:center;">// EXECUTING PROTOCOL: SEARCHING FOR TRUTH...</p>';
      elements.resultPanel.classList.add('loading');
      elements.audioPlayer.style.display = 'none';
      elements.audioPlayer.pause();
      elements.speakIcon.innerHTML = 'ðŸ”Š'; // Reset speak icon

      try {
        const resp = await fetchWithRetry(`${API_BASE}/api/ai/truth`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query })
        });

        if (!resp.ok) {
            elements.resultPanel.innerHTML = '<p style="text-align:center;color:var(--secondary-accent);">// ERROR [CODE: ' + resp.status + ']: CONNECTION TERMINATED.</p>';
            return;
        }

        const data = await resp.json();
        
        if (data.answer) {
            renderContentWithTheme(data.answer);
        } else {
            elements.resultPanel.innerHTML = '<p style="text-align:center;color:var(--secondary-accent);">// WARNING [CODE: 404]: TRUTH NOT FOUND.</p>';
        }

      } catch (error) {
        console.error('API Error:', error);
        elements.resultPanel.innerHTML = `<p style="text-align:center;color:var(--secondary-accent);">// FATAL ERROR: ${error.message.toUpperCase()}<br>VERIFY NETWORK STATUS.</p>`;
      } finally {
        elements.resultPanel.classList.remove('loading');
      }
    }

    // --- Event Listeners ---
    elements.searchBtn.addEventListener('click', () => {
      runQuery(elements.truthInput.value.trim());
    });
    
    elements.truthInput.addEventListener('keydown', function(event) {
      if (event.key === 'Enter') runQuery(elements.truthInput.value.trim());
    });

    elements.copyBtn.addEventListener('click', () => {
        const textToCopy = elements.resultPanel.textContent.trim();
        if (copyToClipboard(textToCopy)) {
            showStatus("// ACTION COMPLETE: OUTPUT COPIED TO CLIPBOARD.");
        } else {
            showStatus("// WARNING: MANUAL COPY REQUIRED. SYSTEM INTERFERENCE DETECTED.", 5000);
        }
    });

    elements.speakBtn.addEventListener('click', () => {
        const contentHtml = elements.resultPanel.innerHTML;
        const isDefaultMessage = contentHtml.includes('INITIATING SEQUENCE') || contentHtml.includes('EXECUTING PROTOCOL') || contentHtml.includes('ERROR');
        
        if (contentHtml && !isDefaultMessage) {
            fetchTTS(contentHtml);
        } else {
            showStatus("// INSTRUCTION DENIED: NOTHING TO TRANSMIT.", 3000);
        }
    });

    // --- Initialization ---
    
    marked.setOptions({
        gfm: true,
        breaks: true,
        sanitize: false, 
        highlight: (code, lang) => lang && hljs.getLanguage(lang)
            ? hljs.highlight(code, { language: lang }).value
            : hljs.highlightAuto(code).value,
    });
    
    window.addEventListener('DOMContentLoaded', () => {
      const history = JSON.parse(localStorage.getItem('truthEngineHistory') || '[]');
      renderHistory(history);

      const params = new URLSearchParams(window.location.search);
      const q = params.get('q');
      if (q) {
        elements.truthInput.value = q;
        runQuery(q);
      }
    });
  </script>
</body>
</html>

