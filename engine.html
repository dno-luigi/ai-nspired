// Main worker export
export default {
  async fetch(request, env, ctx) {
    // CORS headers
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };

    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      const url = new URL(request.url);
      
      // Route handling
      if (url.pathname === '/chat' && request.method === 'POST') {
        return await handleChat(request, env, corsHeaders);
      }
      
      if (url.pathname === '/state' && request.method === 'GET') {
        return await getState(request, env, corsHeaders);
      }

      return new Response('Not Found', { status: 404, headers: corsHeaders });
    } catch (error) {
      return new Response(JSON.stringify({ error: error.message }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  }
};

async function handleChat(request, env, corsHeaders) {
  const body = await request.json();
  const { 
    messages, 
    preset = 'default', 
    userId, 
    sessionId, 
    enableSearch = false, 
    maxContext = 32000 
  } = body;

  // Load existing state
  const stateKey = `session:${sessionId || userId || 'anonymous'}`;
  let sessionState = await loadSessionState(env.KV_STORE, stateKey);

  // Update session state with new messages
  sessionState.messages = [...sessionState.messages, ...messages];
  sessionState.userId = userId || sessionState.userId;

  // Context management with embeddings
  const managedContext = await manageContext(sessionState, maxContext, env);
  
  // Prepare OpenRouter request with preset
  const openRouterRequest = {
    model: `@preset/${preset}`,
    messages: managedContext.messages,
    stream: true,
    tools: getAvailableTools(enableSearch),
    response_format: { type: "text" },
    user: userId
  };

  // Add search context if enabled
  if (enableSearch && messages.length > 0) {
    const searchResults = await performWebSearch(messages[messages.length - 1].content);
    if (searchResults) {
      openRouterRequest.messages.unshift({
        role: "system",
        content: `Current web search context: ${JSON.stringify(searchResults)}`
      });
    }
  }

  // Stream response from OpenRouter
  const openRouterResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
      'Content-Type': 'application/json',
      'HTTP-Referer': 'https://your-domain.com',
      'X-Title': 'Universal AI Proxy'
    },
    body: JSON.stringify(openRouterRequest)
  });

  // Handle streaming response with tool calling
  if (openRouterResponse.body) {
    const { readable, writable } = new TransformStream();
    const writer = writable.getWriter();
    
    // Process stream and handle tool calls
    processStreamWithToolCalls(openRouterResponse.body, writer, env, sessionState, stateKey);
    
    return new Response(readable, {
      headers: {
        ...corsHeaders,
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive'
      }
    });
  }

  return new Response('Stream not available', { status: 500, headers: corsHeaders });
}

async function processStreamWithToolCalls(stream, writer, env, sessionState, stateKey) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  let currentMessage = { role: 'assistant', content: '', tool_calls: [] };

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') {
            // Save final state and close
            sessionState.messages.push(currentMessage);
            await saveSessionState(env.KV_STORE, stateKey, sessionState);
            await writer.write(new TextEncoder().encode('data: [DONE]\n\n'));
            await writer.close();
            return;
          }

          try {
            const parsed = JSON.parse(data);
            const delta = parsed.choices && parsed.choices[0] && parsed.choices[0].delta;

            if (delta) {
              // Handle content
              if (delta.content) {
                currentMessage.content += delta.content;
                await writer.write(new TextEncoder().encode(`data: ${data}\n\n`));
              }

              // Handle tool calls with interleaved thinking
              if (delta.tool_calls) {
                currentMessage.tool_calls.push(...delta.tool_calls);
                
                // Execute tool calls and continue conversation
                for (const toolCall of delta.tool_calls) {
                  if (toolCall.function && toolCall.function.name) {
                    const toolResult = await executeToolCall(toolCall, env);
                    
                    // Add tool result to conversation
                    sessionState.messages.push(currentMessage);
                    sessionState.messages.push({
                      role: 'tool',
                      tool_call_id: toolCall.id,
                      content: JSON.stringify(toolResult)
                    });

                    // Continue conversation with tool result (interleaved thinking)
                    const followUpResponse = await continueWithToolResult(sessionState, env);
                    if (followUpResponse) {
                      await writer.write(new TextEncoder().encode(
                        `data: ${JSON.stringify(followUpResponse)}\n\n`
                      ));
                    }
                  }
                }
              }
            }
          } catch (e) {
            // Skip malformed JSON
            continue;
          }
        }
      }
    }
  } catch (error) {
    await writer.write(new TextEncoder().encode(
      `data: ${JSON.stringify({ error: error.message })}\n\n`
    ));
  } finally {
    await writer.close();
  }
}

async function manageContext(sessionState, maxContext, env) {
  // Simple token estimation (rough approximation)
  let totalTokens = 0;
  const managedMessages = [];
  
  // Always keep system messages and recent messages
  const recentMessages = sessionState.messages.slice(-10);
  const systemMessages = sessionState.messages.filter(m => m.role === 'system');
  
  // Combine and deduplicate
  const combinedMessages = [...systemMessages, ...recentMessages];
  const uniqueMessages = combinedMessages.filter((msg, index, arr) => 
    arr.findIndex(m => JSON.stringify(m) === JSON.stringify(msg)) === index
  );

  // Estimate tokens and trim if necessary
  for (const message of uniqueMessages.reverse()) {
    const messageTokens = estimateTokens(JSON.stringify(message));
    if (totalTokens + messageTokens < maxContext) {
      managedMessages.unshift(message);
      totalTokens += messageTokens;
    } else {
      break;
    }
  }

  return { messages: managedMessages, embeddings: sessionState.embeddings };
}

function estimateTokens(text) {
  // Rough estimation: ~4 characters per token
  return Math.ceil(text.length / 4);
}

function getAvailableTools(enableSearch) {
  const tools = [
    {
      type: "function",
      function: {
        name: "get_current_time",
        description: "Get the current date and time",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      }
    },
    {
      type: "function", 
      function: {
        name: "calculate",
        description: "Perform mathematical calculations",
        parameters: {
          type: "object",
          properties: {
            expression: {
              type: "string",
              description: "Mathematical expression to evaluate"
            }
          },
          required: ["expression"]
        }
      }
    }
  ];

  if (enableSearch) {
    tools.push({
      type: "function",
      function: {
        name: "web_search",
        description: "Search the web for current information",
        parameters: {
          type: "object",
          properties: {
            query: {
              type: "string", 
              description: "Search query"
            }
          },
          required: ["query"]
        }
      }
    });
  }

  return tools;
}

async function executeToolCall(toolCall, env) {
  const { name, arguments: args } = toolCall.function;
  const parsedArgs = JSON.parse(args || '{}');

  switch (name) {
    case 'get_current_time':
      return { time: new Date().toISOString() };
      
    case 'calculate':
      try {
        // Simple math evaluation (be careful with eval in production)
        const result = Function(`"use strict"; return (${parsedArgs.expression})`)();
        return { result, expression: parsedArgs.expression };
      } catch (error) {
        return { error: 'Invalid mathematical expression' };
      }
      
    case 'web_search':
      return await performWebSearch(parsedArgs.query);
      
    default:
      return { error: `Unknown tool: ${name}` };
  }
}

async function performWebSearch(query) {
  // Implement web search using a service like Serper, Brave Search, etc.
  // This is a placeholder implementation
  try {
    // Example using a hypothetical search API
    const response = await fetch(`https://api.search-service.com/search?q=${encodeURIComponent(query)}`, {
      headers: { 'Authorization': 'Bearer YOUR_SEARCH_API_KEY' }
    });
    
    if (response.ok) {
      const results = await response.json();
      return {
        query,
        results: results.results ? results.results.slice(0, 5) : [],
        timestamp: new Date().toISOString()
      };
    }
  } catch (error) {
    console.error('Search error:', error);
  }
  
  return { query, results: [], error: 'Search unavailable' };
}

async function continueWithToolResult(sessionState, env) {
  // Make another OpenRouter call with the updated context including tool results
  const continueRequest = {
    model: '@preset/default', // Use default preset for continuation
    messages: sessionState.messages,
    stream: false,
    max_tokens: 500
  };

  try {
    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(continueRequest)
    });

    if (response.ok) {
      const result = await response.json();
      return result.choices && result.choices[0] && result.choices[0].message;
    }
  } catch (error) {
    console.error('Continue conversation error:', error);
  }

  return null;
}

async function loadSessionState(kv, key) {
  try {
    const stored = await kv.get(key);
    if (stored) {
      return JSON.parse(stored);
    }
  } catch (error) {
    console.error('Error loading session state:', error);
  }

  return {
    messages: [],
    embeddings: [],
    lastUpdated: Date.now(),
    userId: 'anonymous'
  };
}

async function saveSessionState(kv, key, state) {
  try {
    state.lastUpdated = Date.now();
    await kv.put(key, JSON.stringify(state), { expirationTtl: 86400 * 7 }); // 7 days
  } catch (error) {
    console.error('Error saving session state:', error);
  }
}

async function getState(request, env, corsHeaders) {
  const url = new URL(request.url);
  const sessionId = url.searchParams.get('sessionId');
  const userId = url.searchParams.get('userId');
  
  if (!sessionId && !userId) {
    return new Response(JSON.stringify({ error: 'sessionId or userId required' }), {
      status: 400,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }

  const stateKey = `session:${sessionId || userId}`;
  const state = await loadSessionState(env.KV_STORE, stateKey);

  return new Response(JSON.stringify(state), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
  });
}
