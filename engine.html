<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ai-n Forge | Truth Pool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root { --gold: #facc15; --bg: #0a0a15; }
        * { margin:0; padding:0; box-sizing:border-box; font-family:system-ui,-apple-system,sans-serif; }
        body { overflow:hidden; height:100dvh; background:radial-gradient(ellipse at top,#1e1b4b 0%,var(--bg) 70%); touch-action:none; color:white; }
        #canvas { width:100vw; height:100dvh; position:relative; }

        .yard { position:absolute; inset:0; margin:auto; width:90vmin; height:90vmin;
                border:4px solid rgba(250,204,21,0.2); border-radius:40px; box-shadow:0 0 120px rgba(250,204,21,0.25); pointer-events:none; backdrop-filter:blur(6px); }

        .card { position:absolute; width:42vmin; height:42vmin; min-width:320px; min-height:320px;
                background:rgba(255,255,255,0.05); backdrop-filter:blur(70px); border-radius:40px; overflow:hidden;
                box-shadow:0 30px 80px rgba(0,0,0,0.7), inset 0 0 80px rgba(250,204,21,0.1); border:1px solid rgba(250,204,21,0.25);
                transition:all .5s cubic-bezier(0.16,1,0.3,1); touch-action:none; }
        .card.dragging { transform:scale(1.1); z-index:9999; box-shadow:0 0 160px rgba(250,204,21,0.6); }
        .card.fullscreen { position:fixed !important; top:0 !important; left:0 !important; width:100vw !important; height:100dvh !important;
                           border-radius:0 !important; border:none; z-index:10000; }

        .handle { position:absolute; left:20px; top:20px; width:64px; height:64px; background:var(--gold); color:#000;
                  border-radius:20px; display:grid; place-items:center; font-size:36px; font-weight:900;
                  box-shadow:0 0 60px rgba(250,204,21,0.8); z-index:10; }

        .header { height:100px; padding-left:100px; padding-right:30px; display:flex; align-items:center; cursor:grab; }
        .header:active { cursor:grabbing; }
        .title { font-weight:900; font-size:28px; background:linear-gradient(90deg,#facc15,#fbbf24); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }

        /* 2025 CHAT â€“ liquid truth bubbles */
        .messages { height:calc(100% - 160px); padding:20px; overflow-y:auto; display:flex; flex-direction:column; gap:16px; }
        .messages:empty::before { content:"Ask the void..."; opacity:0.4; font-size:18px; text-align:center; margin-top:40%; }
        .bubble { max-width:85%; padding:14px 20px; border-radius:28px; background:rgba(250,204,21,0.15); border:1px solid rgba(250,204,21,0.3);
                  align-self:flex-start; box-shadow:0 8px 32px rgba(0,0,0,0.3); animation:fadeIn 0.6s; backdrop-filter:blur(10px); }
        .bubble pre { background:rgba(0,0,0,0.4); padding:12px; border-radius:12px; overflow-x:auto; }

        .inputbar { height:80px; padding:16px 24px; background:linear-gradient(to top,rgba(0,0,0,0.6),transparent); display:flex; gap:16px; align-items:center; }
        .input { flex:1; background:rgba(255,255,255,0.08); border:1px solid rgba(250,204,21,0.4); border-radius:30px; padding:16px 24px; color:white; font-size:16px; outline:none; resize:none; height:52px; }
        .send { width:56px; height:56px; background:var(--gold); color:#000; border:none; border-radius:50%; font-size:24px; font-weight:900; box-shadow:0 0 40px rgba(250,204,21,0.7); }

        .actions { position:absolute; bottom:24px; right:24px; display:flex; flex-direction:column; gap:16px; z-index:20; }
        .actbtn { width:64px; height:64px; background:rgba(255,255,255,0.12); backdrop-filter:blur(30px); border:1px solid rgba(255,255,255,0.3);
                  border-radius:50%; color:white; font-size:28px; display:grid; place-items:center; box-shadow:0 12px 40px rgba(0,0,0,0.5); }
        .actbtn.close { background:rgba(239,68,68,0.7); }

        .forgebar { position:fixed; top:20px; left:50%; transform:translateX(-50%); background:rgba(15,15,25,0.95); backdrop-filter:blur(50px);
                    padding:16px 32px; border-radius:60px; border:2px solid rgba(250,204,21,0.3); box-shadow:0 30px 80px rgba(0,0,0,0.7); z-index:5000; display:flex; gap:24px; align-items:center; }
        .fbtn { width:72px; height:72px; background:rgba(250,204,21,0.15); border:2px solid var(--gold); border-radius:50%; color:var(--gold); font-size:36px; display:grid; place-items:center; box-shadow:0 0 60px rgba(250,204,21,0.3); }

        @keyframes fadeIn { from { opacity:0; transform:translateY(20px); } to { opacity:1; transform:none; } }
        body:has(.card.fullscreen) .forgebar { opacity:0; pointer-events:none; transition:opacity .5s; }
    </style>
</head>
<body>
    <div id="canvas"><div class="yard"></div></div>

    <div class="forgebar">
        <button class="fbtn" onclick="forge.create('truth')">ðŸ”</button>
        <button class="fbtn" onclick="forge.create('code')">ðŸ’»</button>
        <button class="fbtn" onclick="forge.create('sandbox')">ðŸ§ª</button>
        <button class="fbtn" onclick="forge.create('session')">ðŸ—‚ï¸</button>
        <button class="fbtn" onclick="forge.clear()">ðŸ—‘ï¸</button>
        <span style="color:#facc15; font-weight:900; font-size:20px;" id="count">0/4</span>
    </div>

<script>
class Forge {
    constructor() {
        this.nodes = JSON.parse(localStorage.getItem('forge2x2')||'[]');
        this.memory = JSON.parse(localStorage.getItem('forge-memory')||'[]');
        this.canvas = document.getElementById('canvas');
        this.positions = [{x:8,y:8},{x:50,y:8},{x:8,y:50},{x:50,y:50}];
        this.restore();
    }

    create(type) {
        if (this.nodes.length >= 4) return alert("Yard full â€“ only 4 truths");
        const used = this.nodes.map(n=>`${n.x}-${n.y}`);
        const free = this.positions.find(p => !used.includes(`${p.x}-${p.y}`));
        if (!free) return;
        const node = {id:Date.now(), type, x:free.x, y:free.y, messages:[]};
        this.nodes.push(node);
        this.render(node);
        this.save();
    }

    render(node) {
        const el = document.createElement('div');
        el.className = 'card';
        el.style.left = node.x + 'vmin';
        el.style.top = node.y + 'vmin';
        el.innerHTML = `
            <div class="handle">â˜°</div>
            <div class="header"><div class="title">TRUTH</div></div>
            <div class="messages" id="m${node.id}"></div>
            <div class="inputbar">
                <textarea class="input" id="i${node.id}" placeholder="Speak to the void..."></textarea>
                <button class="send" onclick="forge.send(${node.id})">âž¤</button>
            </div>
            <div class="actions">
                <button class="actbtn" onclick="forge.fullscreen(this)">â›¶</button>
                <button class="actbtn" onclick="forge.saveCard(${node.id})">ðŸ’¾</button>
                <button class="actbtn close" onclick="forge.remove(${node.id})">âœ•</button>
            </div>
        `;
        if (node.messages.length) this.replayMessages(node);
        this.makeDraggable(el.querySelector('.header'), node);
        this.makeDraggable(el.querySelector('.handle'), node);
        this.canvas.appendChild(el);
        node.el = el;
    }

    replayMessages(node) {
        const container = document.getElementById(`m${node.id}`);
        container.innerHTML = '';
        node.messages.forEach(msg => {
            const div = document.createElement('div');
            div.className = 'bubble';
            div.innerHTML = marked.parse(msg);
            container.appendChild(div);
        });
        container.scrollTop = container.scrollHeight;
    }

    makeDraggable(header, node) {
        let startX, startY;
        const move = e => {
            e.preventDefault();
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            node.el.style.left = (node.x + (x-startX)/innerWidth*100) + 'vmin';
            node.el.style.top  = (node.y + (y-startY)/innerHeight*100) + 'vmin';
        };
        const up = () => {
            const rect = node.el.getBoundingClientRect();
            const cx = rect.left + rect.width/2;
            const cy = rect.top + rect.height/2;
            let best = this.positions[0], minDist = Infinity;
            this.positions.forEach(p => {
                if (this.nodes.some(n => n !== node && n.x === p.x && n.y === p.y)) return;
                const px = (p.x + 21) / 100 * innerWidth;
                const py = (p.y + 21) / 100 * innerHeight;
                const dist = Math.hypot(px - cx, py - cy);
                if (dist < minDist) { minDist = dist; best = p; }
            });
            node.x = best.x; node.y = best.y;
            node.el.style.left = node.x + 'vmin';
            node.el.style.top = node.y + 'vmin';
            node.el.classList.remove('dragging');
            this.save();

            document.removeEventListener('pointermove',move);
            document.removeEventListener('pointerup',up);
            document.removeEventListener('touchmove',move);
            document.removeEventListener('touchend',up);
        };
        header.addEventListener('pointerdown', e => {
            if (e.target.tagName==='BUTTON') return;
            node.el.classList.add('dragging');
            startX = e.clientX || e.touches[0].clientX;
            startY = e.clientY || e.touches[0].clientY;
            document.addEventListener('pointermove',move);
            document.addEventListener('pointerup',up);
            document.addEventListener('touchmove',move,{passive:false});
            document.addEventListener('touchend',up);
        });
    }

    async send(id) {
        const node = this.nodes.find(n=>n.id==id);
        if (!node) return;
        const input = document.getElementById('i'+id);
        const query = input.value.trim();
        if (!query) return;

        const messagesDiv = document.getElementById('m'+id);
        const userBubble = document.createElement('div');
        userBubble.className = 'bubble';
        userBubble.style.alignSelf = 'flex-end';
        userBubble.style.background = 'rgba(250,204,21,0.25)';
        userBubble.textContent = query;
        messagesDiv.appendChild(userBubble);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        input.value = '';

        const loading = document.createElement('div');
        loading.className = 'bubble';
        loading.textContent = 'â³';
        messagesDiv.appendChild(loading);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;

        const result = await this.truthEngine(query);
        messagesDiv.removeChild(loading);

        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.innerHTML = marked.parse(result.content);
        messagesDiv.appendChild(bubble);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;

        node.messages.push(query, result.content);
        this.save();
    }

    async truthEngine(query) {
        const result = { content: 'No truth found', source: 'none' };
        try {
            const legacyRes = await fetch('https://truthengine.ai-n.workers.dev/api/ai/truth', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({input:query,model:'polaris-alpha'})});
            const legacy = await legacyRes.json();
            if (legacyRes.ok && legacy.answer) return { content: legacy.answer, source: 'legacy' };

            const resolveRes = await fetch('https://truth.ai-n.workers.dev/api/truth/resolve', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({input:query.toLowerCase().trim().replace(/\s+/g,' ')})});
            const resolve = await resolveRes.json();
            if (resolveRes.ok && resolve.answer) return { content: resolve.answer, source: 'resolve' };

            const proxyRes = await fetch('https://ai-proxy.ai-n.workers.dev/api/chat', {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({message:`Detailed answer: ${query}`,model:'auto'})});
            const proxy = await proxyRes.json();
            if (proxyRes.ok) return { content: proxy.response || proxy.answer || 'No response', source: 'ai' };
        } catch(e) { result.content = `Error: ${e.message}`; }
        return result;
    }

    fullscreen(btn) { btn.closest('.card').classList.toggle('fullscreen'); }
    saveCard(id) {
        const node = this.nodes.find(n=>n.id==id);
        this.memory.unshift({type:'truth', messages:[...node.messages], date:Date.now()});
        localStorage.setItem('forge-memory', JSON.stringify(this.memory.slice(0,100)));
        alert('Truth saved to memory');
    }
    remove(id) {
        const node = this.nodes.find(n=>n.id==id);
        node.el.style.transform = 'scale(0) rotate(360deg)';
        node.el.style.opacity = '0';
        setTimeout(()=>{ node.el.remove(); this.nodes=this.nodes.filter(n=>n.id!=id); this.save(); },600);
    }
    clear() { if(confirm('Wipe the yard?')) { this.nodes=[]; this.canvas.innerHTML='<div class="yard"></div>'; localStorage.removeItem('forge2x2'); document.getElementById('count').textContent='0/4'; } }
    save() { localStorage.setItem('forge2x2',JSON.stringify(this.nodes.map(n=>({id:n.id,type:n.type,x:n.x,y:n.y,messages:n.messages||[]})))); document.getElementById('count').textContent=this.nodes.length+'/4'; }
    restore() { this.nodes.forEach(n=>this.render(n)); document.getElementById('count').textContent=this.nodes.length+'/4'; }
}
const forge = new Forge();
</script>
</body>
</html>