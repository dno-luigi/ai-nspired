<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ai-n Forge | 2x2 Truth Yard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root { --gold: #facc15; --bg: #0a0a15; }
        * { margin:0; padding:0; box-sizing:border-box; font-family:system-ui,-apple-system,sans-serif; }
        body { overflow:hidden; height:100dvh; background:radial-gradient(ellipse at top,#1e1b4b 0%,var(--bg) 70%); touch-action:none; color:white; }
        #canvas { width:100vw; height:100dvh; position:relative; }

        .yard { position:absolute; inset:0; margin:auto; width:90vmin; height:90vmin;
                border:4px solid rgba(250,204,21,0.25); border-radius:32px; box-shadow:0 0 100px rgba(250,204,21,0.3); pointer-events:none; backdrop-filter:blur(4px); }

        .card { position:absolute; width:42vmin; height:42vmin; min-width:300px; min-height:300px; 
                background:rgba(255,255,255,0.06); backdrop-filter:blur(60px); border-radius:32px; overflow:hidden;
                box-shadow:0 20px 60px rgba(0,0,0,0.6), 0 0 80px rgba(250,204,21,0.15); border:1px solid rgba(250,204,21,0.2);
                transition:all .4s cubic-bezier(0.16,1,0.3,1); touch-action:none; }
        .card.dragging { transform:scale(1.08); z-index:9999; box-shadow:0 0 120px rgba(250,204,21,0.5); }
        .card.fullscreen { position:fixed !important; top:0 !important; left:0 !important; width:100vw !important; height:100dvh !important;
                           border-radius:0 !important; z-index:10000; border:none; }

        .handle { position:absolute; left:16px; top:16px; width:56px; height:56px; background:var(--gold); color:#000;
                  border-radius:16px; display:grid; place-items:center; font-size:32px; font-weight:900; z-index:10;
                  box-shadow:0 0 40px rgba(250,204,21,0.7); }

        .header { height:80px; padding-left:90px; padding-right:20px; display:flex; align-items:center; cursor:grab; position:relative; }
        .header:active { cursor:grabbing; }
        .title { font-weight:900; font-size:20px; background:linear-gradient(90deg,var(--gold),#fbbf24); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }

        .content { height:calc(100% - 140px); padding:20px; overflow-y:auto; font-size:15px; line-height:1.7; }
        .content::-webkit-scrollbar { width:4px; }
        .content::-webkit-scrollbar-thumb { background:rgba(250,204,21,0.5); border-radius:2px; }

        .inputbar { height:60px; padding:10px 20px; background:rgba(0,0,0,0.4); border-top:1px solid rgba(250,204,21,0.2); display:flex; gap:12px; align-items:center; }
        .input { flex:1; background:rgba(255,255,255,0.08); border:1px solid rgba(250,204,21,0.4); border-radius:16px; padding:12px; color:white; font-size:15px; outline:none; resize:none; height:44px; }
        .send { width:48px; height:48px; background:var(--gold); color:#000; border:none; border-radius:50%; font-size:20px; font-weight:900; }

        /* Floating 2025 action tray – no more header clutter */
        .actions { position:absolute; bottom:16px; right:16px; display:flex; flex-direction:column; gap:12px; z-index:20; }
        .actbtn { width:56px; height:56px; background:rgba(255,255,255,0.1); backdrop-filter:blur(20px); border:1px solid rgba(255,255,255,0.3);
                  border-radius:50%; color:white; font-size:22px; display:grid; place-items:center; box-shadow:0 8px 32px rgba(0,0,0,0.4); }
        .actbtn.close { background:rgba(239,68,68,0.7); }

        .forgebar { position:fixed; top:16px; left:50%; transform:translateX(-50%); background:rgba(15,15,25,0.95); backdrop-filter:blur(40px);
                    padding:12px 28px; border-radius:50px; border:2px solid rgba(250,204,21,0.3); box-shadow:0 20px 60px rgba(0,0,0,0.6); z-index:5000; display:flex; gap:20px; align-items:center; }
        .fbtn { width:64px; height:64px; background:rgba(250,204,21,0.2); border:2px solid var(--gold); border-radius:50%; color:var(--gold); font-size:28px; display:grid; place-items:center; box-shadow:0 0 40px rgba(250,204,21,0.3); }

        body:has(.card.fullscreen) .forgebar { opacity:0; pointer-events:none; transition:opacity .4s; }
    </style>
</head>
<body>
    <div id="canvas"><div class="yard"></div></div>

    <div class="forgebar">
        <button class="fbtn" onclick="forge.create('truth')"></button>
        <button class="fbtn" onclick="forge.create('code')"></button>
        <button class="fbtn" onclick="forge.create('sandbox')"></button>
        <button class="fbtn" onclick="forge.create('session')"></button>
        <button class="fbtn" onclick="forge.clear()"></button>
        <span style="color:#facc15; font-weight:900; font-size:18px;" id="count">0/4</span>
    </div>

<script>
class Forge {
    constructor() {
        this.nodes = JSON.parse(localStorage.getItem('forge2x2')||'[]');
        this.memory = JSON.parse(localStorage.getItem('forge-memory')||'[]');
        this.canvas = document.getElementById('canvas');
        this.positions = [{x:8,y:8},{x:50,y:8},{x:8,y:50},{x:50,y:50}];
        this.restore();
    }

    create(type) {
        if (this.nodes.length >= 4) return alert("Yard full – only 4 cards");
        const used = this.nodes.map(n=>`${n.x}-${n.y}`);
        const free = this.positions.find(p => !used.includes(`${p.x}-${p.y}`));
        if (!free) return;
        const node = {id:Date.now(), type, x:free.x, y:free.y, content:''};
        this.nodes.push(node);
        this.render(node);
        this.save();
    }

    render(node) {
        const el = document.createElement('div');
        el.className = 'card';
        el.style.left = node.x + 'vmin';
        el.style.top = node.y + 'vmin';
        el.innerHTML = `
            <div class="handle"></div>
            <div class="header"><div class="title">${node.type.toUpperCase()}</div></div>
            <div class="content" id="c${node.id}">${node.type==='truth'?marked.parse(node.content||'Ready for truth...'):''}</div>
            ${node.type==='truth'?`<div class="inputbar"><textarea class="input" id="i${node.id}" placeholder="Ask the Truth Engine..."></textarea><button class="send" onclick="forge.send(${node.id})"></button></div>`:''}
            
            <div class="actions">
                <button class="actbtn" onclick="forge.fullscreen(this)"></button>
                <button class="actbtn" onclick="forge.saveCard(${node.id})"></button>
                <button class="actbtn close" onclick="forge.remove(${node.id})"></button>
            </div>
        `;
        this.makeDraggable(el.querySelector('.header'), node);
        this.makeDraggable(el.querySelector('.handle'), node);
        this.canvas.appendChild(el);
        node.el = el;
    }

    makeDraggable(header, node) {
        let startX, startY;
        const move = e => {
            e.preventDefault();
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            node.el.style.left = (node.x + (x-startX)/window.innerWidth*100) + 'vmin';
            node.el.style.top  = (node.y + (y-startY)/window.innerHeight*100) + 'vmin';
        };
        const up = () => {
            const rect = node.el.getBoundingClientRect();
            const cx = rect.left + rect.width/2;
            const cy = rect.top + rect.height/2;
            let closest = this.positions[0], min = Infinity;
            this.positions.forEach(p => {
                const dist = Math.hypot((p.x+21)/100*innerWidth - cx, (p.y+21)/100*innerHeight - cy);
                if (dist < min && !this.nodes.some(n=>n!==node && n.x===p.x && n.y===p.y)) { min=dist; closest=p; }
            });
            node.x = closest.x; node.y = closest.y;
            node.el.style.left = node.x+'vmin';
            node.el.style.top = node.y+'vmin';
            node.el.classList.remove('dragging');
            this.save();
            document.removeEventListener('pointermove',move);
            document.removeEventListener('pointerup',up);
            document.removeEventListener('touchmove',move);
            document.removeEventListener('touchend',up);
        };
        header.addEventListener('pointerdown', e => {
            if (e.target.tagName==='BUTTON') return;
            node.el.classList.add('dragging');
            startX = e.clientX || e.touches[0].clientX;
            startY = e.clientY || e.touches[0].clientY;
            document.addEventListener('pointermove',move);
            document.addEventListener('pointerup',up);
            document.addEventListener('touchmove',move,{passive:false});
            document.addEventListener('touchend',up);
        });
    }

    // YOUR FULL TRUTH ENGINE – UNTOUCHED, WORKING
    async send(id) {
        const node = this.nodes.find(n=>n.id==id);
        if (!node || node.type !== 'truth') return;
        const input = document.getElementById('i'+id);
        const query = input.value.trim();
        if (!query) return;

        const content = document.getElementById('c'+id);
        content.innerHTML = marked.parse('Searching truth...');
        input.value = '';

        const result = await this.truthEngine(query);
        node.content = result.content;
        content.innerHTML = marked.parse(result.content);
        content.scrollTop = content.scrollHeight;
        this.save();
    }

    async truthEngine(query) {
        const result = { content: 'No truth found', source: 'none' };
        try {
            const legacyRes = await fetch('https://truthengine.ai-n.workers.dev/api/ai/truth', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ input: query, model: 'polaris-alpha' })
            });
            const legacy = await legacyRes.json();
            if (legacyRes.ok && legacy.answer) return { content: legacy.answer, source: 'legacy' };

            const resolveRes = await fetch('https://truth.ai-n.workers.dev/api/truth/resolve', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ input: query.toLowerCase().trim().replace(/\s+/g,' ') })
            });
            const resolve = await resolveRes.json();
            if (resolveRes.ok && resolve.answer) return { content: resolve.answer, source: 'resolve' };

            const proxyRes = await fetch('https://ai-proxy.ai-n.workers.dev/api/chat', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ message: `Detailed answer: ${query}`, model: '@preset/truth' })
            });
            const proxy = await proxyRes.json();
            if (proxyRes.ok) return { content: proxy.response || proxy.answer || 'No response', source: 'ai' };

        } catch(e) { result.content = `Error: ${e.message}`; }
        return result;
    }

    fullscreen(btn) { btn.closest('.card').classList.toggle('fullscreen'); }
    saveCard(id) {
        const node = this.nodes.find(n=>n.id==id);
        if (!node) return;
        const content = document.getElementById('c'+id).innerHTML;
        this.memory.unshift({type:node.type, content, date:Date.now()});
        localStorage.setItem('forge-memory', JSON.stringify(this.memory.slice(0,100)));
        alert('Saved to memory');
    }
    remove(id) {
        const node = this.nodes.find(n=>n.id==id);
        node.el.style.transform = 'scale(0) rotate(180deg)';
        node.el.style.opacity = '0';
        setTimeout(()=>{ node.el.remove(); this.nodes=this.nodes.filter(n=>n.id!=id); this.save(); },500);
    }
    clear() { if(confirm('Wipe the yard?')) { this.nodes=[]; this.canvas.innerHTML='<div class="yard"></div>'; localStorage.removeItem('forge2x2'); document.getElementById('count').textContent='0/4'; } }
    save() { localStorage.setItem('forge2x2',JSON.stringify(this.nodes.map(n=>({id:n.id,type:n.type,x:n.x,y:n.y,content:n.content||''})))); document.getElementById('count').textContent=this.nodes.length+'/4'; }
    restore() { this.nodes.forEach(n=>this.render(n)); document.getElementById('count').textContent=this.nodes.length+'/4'; }
}
const forge = new Forge();
</script>
</body>
</html>