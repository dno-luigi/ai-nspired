<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Truth-Engine | Yellow Mode</title>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.8.0/lib/highlight.min.js"></script>
  
  <style>
    /* ========================================================= */
    /* YELLOW TERMINAL THEME */
    /* ========================================================= */
    :root {
      --bg-color: #000000; /* Black */
      --text-color: #FFC000; /* Bright Yellow/Gold */
      --secondary-text: #FFD700;
      --input-bg: #1A1A1A; /* Dark Grey for contrast */
      --accent-shadow: 0 0 15px rgba(255, 192, 0, 0.4);
      --font-mono: 'Share Tech Mono', monospace;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: var(--font-mono);
      overflow-x: hidden;
      min-height: 100vh;
      box-sizing: border-box;
    }

    #matrix-rain { display: none; } 

    .terminal-container {
      background: rgba(0, 0, 0, 0.9);
      width: 95vw;
      max-width: 1300px;
      height: 95vh;
      min-height: 500px;
      border-radius: 12px;
      margin: 2.5vh auto 0 auto;
      box-shadow: var(--accent-shadow);
      padding: 0;
      z-index: 2;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      border: 2px solid var(--text-color);
    }

    .terminal-header {
      text-align: left;
      padding: 15px 30px 0 30px;
      font-size: 1.8rem;
      color: var(--text-color);
      letter-spacing: 1px;
      text-shadow: 0 0 8px var(--text-color);
    }

    .terminal-body {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      flex: 1 1 auto;
      min-height: 0;
      padding: 0 30px 20px 30px;
      gap: 15px;
    }

    #status-message {
        color: var(--text-color) !important;
        text-shadow: 0 0 5px var(--text-color);
        font-weight: bold;
        text-align: center;
        margin-top: -10px;
        margin-bottom: 10px;
        display: none;
        height: 1em;
    }

    .terminal-history {
      font-size: 1rem;
      color: var(--secondary-text);
      max-height: 10vh;
      overflow-y: auto;
      min-height: 3em;
      margin: 0;
      padding: 0;
      border-bottom: 1px dotted rgba(255, 192, 0, 0.3);
    }
    .terminal-history p { margin: 2px 0; }
    .user-input { color: #FFFFFF; }

    .search-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0;
      width: 100%;
      z-index: 2;
    }

    .terminal-input {
      flex: 1;
      background: var(--input-bg);
      border: 1px solid var(--text-color);
      color: var(--secondary-text);
      font-size: 1rem;
      border-radius: 4px;
      padding: 12px 15px;
      font-family: var(--font-mono);
      outline: none;
      transition: border 0.18s, box-shadow 0.18s;
      box-shadow: inset 0 0 8px rgba(255, 192, 0, 0.2);
    }
    .terminal-input:focus {
      border-color: #FFFFFF;
      box-shadow: 0 0 10px #FFFFFF40, inset 0 0 8px var(--text-color);
    }

    .action-row {
        display: flex;
        gap: 10px;
        width: 100%;
        margin-top: -5px;
        margin-bottom: 5px;
    }
    
    .matrix-btn, .action-btn {
      background: var(--text-color);
      border: 1px solid var(--bg-color);
      color: var(--bg-color);
      border-radius: 4px;
      font-size: 1rem;
      font-family: var(--font-mono);
      padding: 10px 20px;
      cursor: pointer;
      transition: background 0.14s, color 0.14s, box-shadow 0.14s;
      letter-spacing: 1px;
      font-weight: bold;
      box-shadow: 0 0 8px var(--text-color);
    }
    .matrix-btn:hover, .action-btn:hover {
      background: var(--secondary-text);
      box-shadow: 0 0 15px var(--secondary-text);
    }
    
    .action-btn {
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        /* Adjusted padding for icon-only button */
        padding: 10px 5px; 
    }
    .action-btn span, .action-btn svg {
        font-size: 1.5em; /* Larger icon size */
    }
    .action-btn svg {
        width: 1.5em;
        height: 1.5em;
        stroke: var(--bg-color);
        fill: none;
    }
    
    #audio-player {
        width: 100%;
        height: 40px;
        margin-top: 5px;
        filter: hue-rotate(90deg) saturate(2); 
    }
    
    .result-panel {
      background: var(--input-bg);
      border: 1px dashed var(--text-color);
      border-radius: 8px;
      color: #FFF; /* Changed to white for better readability against yellow theme */
      font-size: 1.1rem;
      min-width: 0;
      flex: 1 1 0%;
      width: 100%;
      max-height: 100%;
      min-height: 0;
      overflow-y: auto;
      margin: 0 auto;
      box-shadow: 0 0 15px rgba(255, 192, 0, 0.15);
      animation: fadeIn 0.6s;
      word-break: break-word;
      padding: 20px;
      line-height: 1.5;
    }

    /* Result Panel Content Styling */
    .result-panel h3, .result-panel strong { color: var(--secondary-text); }
    .result-panel a { color: #FFF; text-decoration: underline; cursor: pointer; }
    .result-panel a:hover { color: var(--text-color); }
    .result-panel code, .result-panel pre {
      background: #0D0208;
      border: 1px solid rgba(255, 192, 0, 0.2);
      border-radius: 4px;
      color: var(--secondary-text);
      padding: 8px 14px;
      font-family: var(--font-mono);
      font-size: 0.9em;
      display: block;
      margin: 14px 0;
      overflow-x: auto;
    }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    @media (max-width: 600px) {
      .terminal-header { font-size: 1.2rem; padding: 10px 15px 0 15px; }
      .terminal-body { padding: 0 15px 10px 15px; }
      .result-panel { font-size: 1rem; padding: 15px; }
      .search-row { flex-direction: column; gap: 8px; }
      .matrix-btn { width: 100%; padding: 12px 15px; }
      .terminal-input { padding: 12px 12px; }
      .action-btn { padding: 8px 5px; }
    }
  </style>
</head>
<body>
  <div class="terminal-container">
    <!-- Restored the header from your provided code -->
    <div class="terminal-header">ai-nspired://>root@TRUTH-ENGINE</div>
    <div class="terminal-body">
      <div id="status-message"></div>
      
      <div class="terminal-history" id="terminal-history">
        <p>&gt; <span style="color:#FFF;">// SYSTEM INITIATED. Yellow Mode Online.</span></p>
        <p>&gt; Enter query below and press RUN or ENTER.</p>
      </div>

      <div class="search-row">
        <input type="text" id="truth-input" class="terminal-input" placeholder="uncover the truth..." autocomplete="off" />
        <button class="matrix-btn" id="search-btn">RUN</button>
      </div>
      
      <!-- TTS and Copy Buttons (Icon Only) -->
      <div class="action-row">
          <button id="speak-btn" class="action-btn icon-only" title="Read Response Aloud">
              <span id="speak-icon">🔊</span>
          </button>
          <button id="copy-btn" class="action-btn icon-only" title="Copy Output to Clipboard">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2"/>
                  <path d="M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
              </svg>
          </button>
      </div>
      <!-- Removed style="display:none" to ensure the player is visible when audio loads -->
      <audio id="audio-player" controls></audio> 

      <!-- Result Panel -->
      <div id="result-panel" class="result-panel">
        <p style="text-align:center;color:var(--text-color);">// AWAITING INSTRUCTION</p>
      </div>
    </div>
  </div>
  
  <script>
    // Configuration for the CUSTOM AI SERVICE (ai-n.org)
    const API_BASE = 'https://justice.ai-n.workers.dev'; 
    
    // Element map
    const elements = {
        truthInput: document.getElementById('truth-input'),
        searchBtn: document.getElementById('search-btn'),
        terminalHistory: document.getElementById('terminal-history'),
        resultPanel: document.getElementById('result-panel'),
        statusMessage: document.getElementById('status-message'),
        copyBtn: document.getElementById('copy-btn'),
        speakBtn: document.getElementById('speak-btn'),
        speakIcon: document.getElementById('speak-icon'),
        audioPlayer: document.getElementById('audio-player'),
    };

    // TTS API details (Standard Gemini TTS is used to generate audio data)
    const TTS_API_BASE = "https://generativelanguage.googleapis.com/v1beta";
    const TTS_MODEL = "gemini-2.5-flash-preview-tts";
    const apiKey = ""; 

    // --- Utility Functions ---

    function showStatus(message, duration = 3000) {
        elements.statusMessage.textContent = message;
        elements.statusMessage.style.display = 'block';
        setTimeout(() => elements.statusMessage.style.display = 'none', duration);
    }

    function copyToClipboard(text) {
        const tempElement = document.createElement('textarea');
        tempElement.value = text;
        document.body.appendChild(tempElement);
        tempElement.select();
        try {
            document.execCommand('copy'); 
            return true;
        } catch (err) {
            console.error('Copy failed:', err);
            return false;
        } finally {
            document.body.removeChild(tempElement);
        }
    }

    function addTerminalLine(line, isUser = false) {
      const p = document.createElement('p');
      p.innerHTML = isUser
        ? `&gt; <span class="user-input">${escapeHTML(line)}</span>`
        : `&gt; ${escapeHTML(line)}`;
      elements.terminalHistory.appendChild(p);
      elements.terminalHistory.scrollTop = elements.terminalHistory.scrollHeight;
    }
    
    function escapeHTML(str) {
      return String(str).replace(/[&<>"']/g, m => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
      })[m]);
    }
    
    /**
     * Helper to write a string into a DataView at a given offset.
     */
    function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }

    /**
     * Converts Int16Array PCM audio data to a WAV Blob.
     */
    function pcmToWav(pcm16, sampleRate) {
        // RIFF header (44 bytes) + data (2 bytes per sample)
        const buffer = new ArrayBuffer(44 + pcm16.length * 2);
        const view = new DataView(buffer);
        
        // RIFF chunk descriptor
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + pcm16.length * 2, true); // Chunk size
        writeString(view, 8, 'WAVE');
        
        // FMT sub-chunk
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true); // Sub-chunk 1 size (16 for PCM)
        view.setUint16(20, 1, true); // Audio format (1 for PCM)
        view.setUint16(22, 1, true); // Number of channels (1)
        view.setUint32(24, sampleRate, true); // Sample rate
        view.setUint32(28, sampleRate * 2, true); // Byte rate (SampleRate * NumChannels * BitsPerSample/8)
        view.setUint16(32, 2, true); // Block align (NumChannels * BitsPerSample/8)
        view.setUint16(34, 16, true); // Bits per sample (16)
        
        // Data sub-chunk
        writeString(view, 36, 'data');
        view.setUint32(40, pcm16.length * 2, true); // Sub-chunk 2 size (data size)
        
        // Write the PCM data
        for (let i = 0; i < pcm16.length; i++) {
            view.setInt16(44 + i * 2, pcm16[i], true);
        }
        
        return new Blob([buffer], { type: 'audio/wav' });
    }
    
    /**
     * Converts a base64 string to an ArrayBuffer.
     */
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    /** Handles TTS generation and playback using the Gemini API (Kore voice) */
    async function fetchTTS(htmlContent) {
        // Stop and hide the player at the start of a new request
        elements.audioPlayer.style.display = 'none';
        elements.audioPlayer.pause();
        elements.speakIcon.textContent = '...'; 
        elements.speakBtn.disabled = true;

        const cleanText = htmlContent.replace(/<[^>]+>/g, '').replace(/[\*\_#]/g, '').trim();
        if (!cleanText) {
             elements.speakIcon.textContent = '🔊';
             elements.speakBtn.disabled = false;
             return showStatus('// PROTOCOL FAILURE: NO CONTENT TO TRANSMIT.', 3000);
        }
        
        const payload = {
            contents: [{ parts: [{ text: cleanText }] }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: "Kore" }
                    }
                }
            },
            model: TTS_MODEL
        };
        
        const apiUrl = `${TTS_API_BASE}/models/${TTS_MODEL}:generateContent?key=${apiKey}`;

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) throw new Error("TTS API call failed with status: " + response.status);
            
            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;

            if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                const rateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                const audioUrl = URL.createObjectURL(wavBlob);
                
                elements.audioPlayer.src = audioUrl;
                elements.audioPlayer.style.display = 'block';
                elements.speakIcon.textContent = '▶️';
                elements.speakBtn.disabled = false;
                
                // CRITICAL FIX: Use promise-based play() and catch failure due to autoplay restrictions
                elements.audioPlayer.play().catch(e => {
                    console.error("Autoplay prevented:", e);
                    showStatus("// WARNING: AUTOPLAY BLOCKED. CLICK PLAY BUTTON ON AUDIO BAR.", 5000);
                    elements.speakIcon.textContent = '🔊'; // Reset icon if play is blocked
                });
                
                elements.audioPlayer.onended = () => {
                    elements.speakIcon.textContent = '🔊';
                };

            } else {
                throw new Error("Invalid audio data format received or generation failed.");
            }
        } catch (error) {
            console.error("TTS Error:", error);
            showStatus('// TTS SYSTEM ERROR. COULD NOT GENERATE AUDIO.', 5000);
            elements.speakIcon.textContent = '🔊';
            elements.speakBtn.disabled = false;
        }
    }


    // --- Core Logic (Search) ---

    async function runQuery(queryText) {
      if (!queryText || !queryText.trim()) return;
      
      const query = queryText.trim();
      addTerminalLine(query, true);
      elements.truthInput.value = '';
      elements.resultPanel.style.display = 'block';
      
      elements.resultPanel.innerHTML = `<p style="text-align:center;color:#FFF;">// EXECUTING PROTOCOL: SEARCHING FOR TRUTH...</p>`;
      elements.audioPlayer.style.display = 'none';
      elements.audioPlayer.pause();
      elements.speakIcon.textContent = '🔊';
      
      try {
        // Using the custom endpoint and payload structure you provided
        const response = await fetch(`${API_BASE}/api/ai/truth`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query: query })
        });

        if (!response.ok) {
            elements.resultPanel.innerHTML = '<p style="text-align:center;color:red;">// ERROR [CODE: ' + response.status + ']: CUSTOM API CONNECTION FAILED. Status is not 200 OK.</p>';
            return;
        }

        const data = await response.json();
        
        if (data.answer) {
          let html = marked.parse(data.answer);
          
          let sourcesHtml = '';
          if (data.citations && Array.isArray(data.citations) && data.citations.length > 0) {
              sourcesHtml = `<div style="margin-top:20px; border-top: 1px dotted rgba(255, 192, 0, 0.3); padding-top: 10px;">
                  <strong>// Sources Found:</strong><ul style="margin-bottom:0; padding-left: 20px;">` +
                  data.citations.map(c =>
                      `<li><a href="${c.url}" target="_blank" rel="noopener noreferrer">${escapeHTML(c.title || c.url)}</a></li>`
                  ).join('') +
                  `</ul></div>`;
          }
          
          elements.resultPanel.innerHTML = html + sourcesHtml;

          if (window.hljs) {
            elements.resultPanel.querySelectorAll('pre code').forEach(block => { hljs.highlightElement(block); });
          }
        } else {
            elements.resultPanel.innerHTML = `<p style="text-align:center;color:red;">// WARNING: TRUTH NOT FOUND. Custom API returned no answer content.</p>`;
        }

      } catch (error) {
        console.error('API Error:', error);
        elements.resultPanel.innerHTML = `<p style="text-align:center;color:red;">// FATAL ERROR: ${error.message.toUpperCase()}<br>VERIFY NETWORK STATUS AND CUSTOM API ENDPOINT.</p>`;
      }
    }

    // --- Event Listeners ---
    
    elements.searchBtn.addEventListener('click', () => {
      runQuery(elements.truthInput.value);
    });
    
    elements.truthInput.addEventListener('keydown', function(event) {
      if (event.key === 'Enter') runQuery(elements.truthInput.value);
    });

    elements.copyBtn.addEventListener('click', () => {
        const textToCopy = elements.resultPanel.textContent.trim();
        const isDefaultMessage = textToCopy.includes('// EXECUTING PROTOCOL') || textToCopy.includes('// WARNING') || textToCopy.includes('// FATAL ERROR') || textToCopy.includes('// AWAITING INSTRUCTION');
        
        if (isDefaultMessage) {
             return showStatus("// INSTRUCTION DENIED: NO VALID OUTPUT DETECTED.", 3000);
        }
        if (copyToClipboard(textToCopy)) {
            showStatus("// ACTION COMPLETE: OUTPUT COPIED TO CLIPBOARD.");
        } else {
            showStatus("// WARNING: MANUAL COPY REQUIRED. SYSTEM INTERFERENCE DETECTED.", 5000);
        }
    });

    elements.speakBtn.addEventListener('click', () => {
        const contentHtml = elements.resultPanel.innerHTML;
        const isDefaultMessage = contentHtml.includes('// AWAITING INSTRUCTION') || contentHtml.includes('// EXECUTING PROTOCOL') || contentHtml.includes('// ERROR') || contentHtml.includes('// WARNING');
        
        if (contentHtml && !isDefaultMessage) {
            fetchTTS(contentHtml);
        } else {
            showStatus("// INSTRUCTION DENIED: NOTHING TO TRANSMIT.", 3000);
        }
    });

    // --- Initialization ---
    
    marked.setOptions({
        gfm: true,
        breaks: true,
        sanitize: false, 
        highlight: (code, lang) => lang && hljs.getLanguage(lang)
            ? hljs.highlight(code, { language: lang }).value
            : hljs.highlightAuto(code).value,
    });
  </script>
</body>
</html>

